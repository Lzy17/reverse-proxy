#!/bin/bash

## Authors: Developed by James McDougall [Github JamesMcDougallJr], Scott Sakai, 
## and Mary Thomas. The goal of this script is to start a jupyter notebook on various 
## HPC Systems by using the Reverse Proxy service. This makes a secure connection 
## between the user's local machine and the RP server.

## ====================================================================================
## Usage
##  ./start_notebook [-p <string>] [-d <string>] [-b <string>] [-t <number>]
##
##      -p: The partition your job will be started on. This can be either compute or
##          debug. Reminder that the debug queue has a max time of 30 minutes.
##
##      -d: The top level directory for your jupyter notebook. 
##          Default: /home/$USER 
##
##      -A: The Allocation (project) your notebook will be "charged" to. 
##          Default: the same as your system default. This is different for every user, 
##          but you can see your accounts using the `show_accounts` command.
##
##      -b: The batch script you want to submit. Of course the batch script needs to
##          start a jupyter notebook otherwise this script will fail.
##          Default: ./batch/batch_notebook.sh
##
##      -t: The time in MINTUES that you want the jupyter notebook to run for.
##          Default: 30 minutes
##
##
## =====================================================================================

INFO=0

start_dir=""
runtime=""
# which account to charge the compute time to
project=""
# compute or debug on comet
partition=""
# path to the batch script to submit
batch_script=""
# the runtime the user gives
input_runtime=""
# environment variable. default is a singularity container
environment=""
# used for GETOPTS
OPTIND=1

# Submits the a batch job which defines a jupyter notebook
# Note that behavior is undefined if you configure the script to use
# a batch script that doesn't work or submits something other than a jupyter
# notebook. Its not recommended that you change anything in this function.
function start_notebook () {

    # if the cluster is tscc or tscc-stratus, use tscc-user-content
    # otherwise use comet-user-content
    hostname=$(hostname -s)
    export cluster=${hostname%-*}

    # get the Reverse proxy API_TOKEN
    api_token_response=$(curl -s https://manage.$cluster-user-content.sdsc.edu/getlink.cgi)

    # strip the token out of response
    api_token=${api_token_response#*"Your token is "}     

    # removes the newline char
    api_token=$(echo "$api_token" | tr '\n' ' ') 

    # remove extra spaces before or after
    export api_token=$(echo "$api_token" | xargs) 

    if [[ $api_token_response == Oops!* ]]
    then
        echo $api_token_response
        exit 1
    fi

    if jupyter --config-dir; then
        JUP_CONFIG_DIR="$(jupyter --config-dir)/rps"
    else 
        echo "It looks like you don't have jupyter installed on your account."
        echo "To learn how to install Miniconda, check out this link: https://comet-notebooks-101.readthedocs.io/en/comet/prerequisites.html"
        exit 0
    fi

    # ensure the jupyter config directory exists and is accessible.
    # make a temp file there for the rps to read tokens
    mkdir -p $JUP_CONFIG_DIR || (echo "Failed to create directory $JUP_CONFIG_DIR" && exit 1)
    chmod 0700 $JUP_CONFIG_DIR || (echo "Failed to change permissions on directory $JUP_CONFIG_DIR" && exit 1)
    export config=`mktemp -p $JUP_CONFIG_DIR tmp.XXXXXX.py` 

    if [[ $config = "" ]]; then
        echo "Failed to make tempfile in $JUP_CONFIG_DIR"
        exit 1
    fi

    # Make a random ssl token
    jupyter_token=$(openssl rand -hex 16)

    # Create the temp config file
    echo "c.NotebookApp.token = '$jupyter_token'" | cat >> "$config"

    if [ "$start_dir" = "" ]; then
        echo "c.NotebookApp.notebook_dir = '/home/$USER/'" | cat >> "$config"
    else
        echo "c.NotebookApp.notebook_dir = '$start_dir'" | cat >> "$config"
    fi

    echo "c.NotebookApp.allow_origin = '*'" | cat >> "$config"
    echo "c.NotebookApp.allow_remote_access = True" | cat >> "$config"

    # Give the user their url
    export jupyter_url="https://$api_token.$cluster-user-content.sdsc.edu?token=$jupyter_token"
    echo Your notebook is here:
    echo -e "\t$jupyter_url"

    # start the batch script with the api token and the starting directory
    # Argument 1 to the batch script is the RP api token
    # Argument 2 to the batch script is the config path

    if [ "$partition" = "" ]; then
        if [[ "$cluster" = "comet" ]]
        then
            partition="compute"
        else
            partition="interactive"
        fi
        echo "Using default partition: $partition"
    fi

    if [ "$runtime" = "" ]; then
        echo "No time allotment given. Default is 30 mins" 
        runtime="00:30:00"
    fi

    
    if [[ $INFO -eq 1 ]]; then
        echo "******************Start notebook info**********************" 
        echo "User $USER"
        echo "On cluster $cluster"
        echo "Using default project" 
        echo "Batch Script: $batch_script"
        echo "Partition: $partition"
        echo "Tempfile: $config"
        echo "Api token: $api_token"
        echo "Jupyter token: $jupyter_token"
        echo "Runtime: $runtime"
        echo "***********************************************************"
    fi

    export start_root=$PWD

    # if sbatch is available, submit a job using that.
    if [[ $(which sbatch 2> /dev/null) != "" ]]
    then
        if [ "$batch_script" = "" ]; then
            echo "No batch script specified. Using ./slurm/notebook.sh"
            batch_script="./slurm/notebook.sh"
        fi

        comment="User,\n$USER,"
        if [ "$project" = "" ]; then
            sbatch --comment=$comment -t $runtime -p $partition --export=api_token,config,cluster,start_root $batch_script
        else
            sbatch --comment=$comment -t $runtime -A $project -p $partition --export=api_token,config,cluster,start_root $batch_script 
        fi
    elif [[ $(which qsub 2> /dev/null) != "" ]]
        if [ "$batch_script" = "" ]; then
            echo "No batch script specified. Using ./torque/notebook.sh"
            batch_script="./torque/notebook.sh"
        fi
        if [[ $project = "" ]]
        then
            qsub -l walltime=$runtime $batch_script
        else
            qsub -l walltime=$runtime -A $project $batch_script
        fi
    else
        echo "No queue system was found. Please use slurm or torque"
    fi
}

usage() { 
    echo "Usage: $0 [-p <string>] [-d <string>] [-A <string>] [-b <string>] [-t time] [-i]" 1>&2;
    echo -e "-p: the partition to use, debug or compute. Default is compute" 1>&2;
    echo -e "-d: the top-level directory of your jupyter notebook. Default is /home/$USER" 1>&2;
    echo -e "-A: the project allocation to be used for this notebook. Default is system default (also called project or group)" 1>&2;
    echo -e "-b: the batch script you want to submit. Only those in the batch folder are supported. Default is ./batch/batch_notebook.sh" 1>&2;
    echo "-t: the time to run the notebook. Default is 30 minutes" 1>&2;
    echo "-i: Get extra information about the job you submitted using the script" 1>&2;
}

source lib/parse_time.sh

while getopts "h?:d:A:p:b:t:i:e" opt; do
    case "$opt" in
        h|\?)
            usage 
            exit 0
            ;;
        d)  start_dir=$OPTARG ;;
        A)  project=$OPTARG   ;;
        p)  partition=$OPTARG ;;
        b)  batch_script=$OPTARG ;;
        i)  INFO=1 ;;
        t)  input_runtime=$OPTARG 
            runtime=$(parse_time $OPTARG) 
            ;;
        *)  echo "Error: invalid optional argument $OPTARG" 
            usage 
            exit 1
            ;;
    esac
done

if [[ $partition = "debug" ]]; then
    if [[ $input_runtime -gt 30 ]]; then
        echo "Invalid runtime for debug queue. Must be less than or equal to 30 minutes"
        exit 1
    fi
fi

start_notebook $start_dir $runtime $project
